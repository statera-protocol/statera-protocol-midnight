module CustomLibrary {
    import CompactStandardLibrary;
    export { MintMetadata, calculateHFactor, DivisionFunction, generateUserId, getMintMetadata, hashMintMetadata, generateAdminId, ComplianceToken, KYCTokenData, ValidityRange};
    
    /* Structure for Private state */
    struct MintMetadata {
        collateral: Uint<64>;
        debt: Uint<64>;
    }

    struct KYCTokenData {
        // User's DID identifier
        did: Bytes<32>;
        // User's PublicKey
        userPk: Bytes<32>;
        // Oracle public key
        oraclePk: Bytes<32>;
        // Validity range for the token
        validityRange: ValidityRange;
    }

    struct ValidityRange {
        duration: Uint<64>;
        creationDate: Uint<64>;
    }

    struct ComplianceToken {
        tokenData: KYCTokenData;
        // Signature from oracle to verify authenticity of the token
        oracleSignature: Bytes<32>;
    }

    witness division(divident: Uint<64>, divisor:Uint<64>): [Uint<64>, Uint<64>];
    witness get_mintmetadata_private_state(): MintMetadata;
    
 
    circuit calculateHFactor(collateralAmount: Uint<64>, amountToMint: Uint<64>, liquidationThreshold: Uint<8>): Uint<128>{
        const percentageDivisor: Uint<64> = 100;
        const healthFactor = DivisionFunction((collateralAmount * liquidationThreshold) as Uint<64>, (amountToMint * percentageDivisor) as Uint<64>);
        return healthFactor;
    }

    circuit DivisionFunction(dividend: Uint<64>, divisor: Uint<64>): Uint<128> {
        assert (divisor != 0, "Invalid divisor provided");
        
        const [quotient, remainder] = disclose(division(dividend, divisor));
        assert (remainder < divisor, "Reminder error");
        assert (quotient * divisor + remainder == dividend, "Invald divison result");
        return quotient;
    }

    circuit generateUserId(sk: Bytes<32>): Bytes<32>{
        return persistentHash<Vector<2, Bytes<32>>>(
            [ 
                pad(32, "susd:user"),
                persistentHash<Vector<2, Bytes<32>>>(
                    [sk, kernel.self().bytes]
                )
             ]
        );
    }

    circuit generateAdminId(sk: Bytes<32>): Bytes<32>{
        return persistentHash<Vector<2, Bytes<32>>>(
            [ 
                pad(32, "susd:admin"),
                persistentHash<Vector<2, Bytes<32>>>(
                    [sk, kernel.self().bytes]
                )
             ]
        );
    }

    circuit getMintMetadata(): MintMetadata{
        const {debt, collateral} = disclose(get_mintmetadata_private_state());
        return MintMetadata {
            collateral,
            debt
        };
    } 

    circuit hashMintMetadata (metadata: MintMetadata, randomizer: Bytes<32>): Bytes<32> {
        return persistentCommit<MintMetadata>(metadata, randomizer);
    }
    
}
